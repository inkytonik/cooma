module org.bitbucket.inkytonik.cooma.CoomaParser;

header {
    import org.bitbucket.inkytonik.cooma.CoomaParserSyntax.*;
}

// Cooma source language

Program =
  Spacing Expression EOF.

Expression {paren} =
    "fun" '(' Argument ++ "," ")" "=>" Expression   {Fun, right, 4}
  | Expression '(' Expression ++ "," ')'            {App, left, 3}
  | Expression "&" Expression                       {And, left, 2}
  | Expression '.' Identifier                       {Sel, left, 1}
  | '{' Field ** "," '}'                            {Row}
  | Block
  | IntLit                                          {Num, 1: Integer.parseInt : Int}
  | Identifier                                      {IdnUse}
  | StringLit                                       {Str}.

Argument =
  Identifier sp ":" Type.

Field =
  Identifier sp "=" Expression.

Block : Expression =
  '{' nestnl (BlockExp) \n '}'.

BlockExp =
    FunctionDefinition+ BlockExp   {LetFun}
  | ValueDefinition BlockExp       {LetVal}
  | Expression                     {Return}.

FunctionDefinition =
  "def" Identifier sp '(' Argument ++ "," ")" '='
    nestnl (Expression) \n                {Def}.

ValueDefinition =
  "val" Identifier sp "=" Expression \n   {Val}.

Type =
    Type sp "=>" Type         {FunT, right, 1}
  | RowType                   {PiT}
  | 'Int'                     {IntT}
  | 'String'                  {StrT}
  | Identifier                {IdnT}.

RowType =
  '{' FieldType ** "," '}'.

FieldType =
  Identifier sp ":" Type.

// Continuation-based intermediate representation

Value =
    Identifier sp "&" Identifier                  {AndV}
  | "arg" IntLit                                  {ArgV, 1: Integer.parseInt : Int}
  | "cap" Identifier sp Identifier                {CapV}
  | "fun" Identifier sp Identifier sp "=>" Term   {FunV}
  | IntLit                                        {IntV, 1: Integer.parseInt : Int}
  | "prm" Identifier sp Identifier+               {PrmV}
  | '{' FieldValue ** "," '}'                     {RowV}
  | Identifier '.' Identifier                     {SelV}
  | StringLit                                     {StrV}.

FieldValue =
  Identifier sp "=" Identifier.

Term =
    "letc" Identifier sp Identifier sp "=" Term sp 'in'
      nestnl (Term)                                      {LetC}
  | "letf" nestnl (DefTerm+) 'in'
      nestnl (Term)                                      {LetF}
  | "letv" Identifier sp "=" Value sp 'in'
      nestnl (Term)                                      {LetV}
  | Identifier sp Identifier sp Identifier               {AppF}
  | Identifier sp Identifier                             {AppC}
  | "halt" Identifier                                    {Halt}.

DefTerm =
  Identifier sp Identifier sp Identifier sp "=" Term \n.

// Lexical syntax

IntLit : Token =
  Digits.

Digits : String =
  Digit+.

Digit : String =
  [0-9].

StringLit : Token =
  '"' StringChar* '"'.

StringChar : String =
  '\\' ([btnfr] / '\\' / '"' / "'" /
        OctDigit OctDigit OctDigit /
        OctDigit OctDigit /
        OctDigit OctDigit) /
  !'"' _.

OctDigit : String =
  [0-7].

// Constructs used by REPL parsing

Whitespace : Void =
  Spacing EOF.

REPLInput =
  Spacing REPLEntry EOF.

REPLEntry : REPLInput =
    Expression            {REPLExpression}
  | FunctionDefinition    {REPLDef}
  | ValueDefinition       {REPLVal}.
