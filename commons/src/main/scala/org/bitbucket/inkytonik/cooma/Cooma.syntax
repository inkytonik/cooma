module org.bitbucket.inkytonik.cooma.CoomaParser;

header {
    import org.bitbucket.inkytonik.cooma.CoomaParserSyntax.*;
    import scala.math.BigInt;
}

// Cooma source language

Program =
  Spacing Expression EOF.

Expression {paren} =
    "fun" '(' Arguments ")" "=" Expression    {Fun, right, 4}
  | Expression '(' Expression ** "," ')'      {App, left, 3}
  | Expression "&" Expression                 {Cat, left, 2}
  | Expression '.' FieldUse                   {Sel, left, 1}
  | '{' nestnl (BlockExp) \n '}'              {Blk}
  | IntLit                                    {Num, 1: BigInt.apply : BigInt}
  | '{' Field ** "," '}'                      {Rec}
  | StringLit                                 {Str}
  | IdnUse                                    {Var}
  | '(' Expression ')'.

Arguments =
  Argument ** ",".

Argument =
  IdnDef sp ":" Type.

Field =
  Identifier sp "=" Expression.

FieldUse =
  Identifier.

BlockExp =
    Def+ BlockExp   {LetFun}
  | Typ BlockExp    {LetTyp}
  | Val BlockExp    {LetVal}
  | Expression      {Return}.

Def =
  "def" IdnDef sp Body \n.

Body =
  '(' Arguments ")" ":" Type sp '=' nestnl (Expression).

Typ =
  "type" IdnDef sp "=" Type \n.

Val =
  "val" IdnDef sp "=" Expression \n.

Type =
    '(' Type ** "," ")" "=>" Type  {FunT, right, 1}
  | RowType                        {PiT}
  | 'Int'                          {IntT}
  | 'String'                       {StrT}
  | IdnUse                         {IdnT}.

RowType =
  '{' FieldType ** "," '}'.

FieldType =
  Identifier sp ":" Type.

// Lexical syntax

IdnDef =
  Identifier.

IdnUse =
  Identifier.

IntLit : Token =
  '-'? Digits.

Digits : String =
  Digit+.

Digit : String =
  [0-9].

StringLit : Token =
  '"' StringChar* '"'.

StringChar : String =
  '\\' ([btnfr] / '\\' / '"' / "'" /
        OctDigit OctDigit OctDigit /
        OctDigit OctDigit /
        OctDigit OctDigit) /
  !'"' _.

OctDigit : String =
  [0-7].

// Constructs used by REPL parsing

Whitespace : Void =
  Spacing EOF.

REPLInput =
  Spacing REPLEntry EOF.

REPLEntry : REPLInput =
    Expression  {REPLExpression}
  | Def         {REPLDef}
  | Val         {REPLVal}.
