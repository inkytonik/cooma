{
  // Booleans

  type Boolean = <<False : Unit, True : Unit>>

  val false : Boolean = <<False = {}>>
  val true : Boolean = <<True = {}>>

  def ite(t : Type, b : Boolean, l : t, r : t) t =
    b match {
      case True(_) => l
      case False(_) => r
    }

  val Booleans = {
    and = fun (l : Boolean, r : Boolean) ite(Boolean, l, r, false),
    not = fun (b : Boolean) ite(Boolean, b, false, true),
    or = fun (l : Boolean, r : Boolean) ite(Boolean, l, true, r)
  }

  def equal(t : Type, l : t, r : t) Boolean =
    prim Equal(t, l, r)

  // Operations on pre-defined types

  val Ints = {
    abs = fun (i : Int) prim IntAbs(i),
    add = fun (l : Int, r : Int) prim IntAdd(l, r),
    div = fun (l : Int, r : Int) prim IntDiv(l, r),
    mod = fun (l : Int, r : Int) prim IntMod(l, r),
    mul = fun (l : Int, r : Int) prim IntMul(l, r),
    pow = fun (l : Int, r : Int) prim IntPow(l, r),
    sub = fun (l : Int, r : Int) prim IntSub(l, r),
    lt = fun (l : Int, r : Int) prim IntLt(l, r),
    lte = fun (l : Int, r : Int) prim IntLte(l, r),
    gt = fun (l : Int, r : Int) prim IntGt(l, r),
    gte = fun (l : Int, r : Int) prim IntGte(l, r)
  }

  val Strings = {
    concat = fun (l : String, r : String) prim StrConcat(l, r),
    length = fun (s : String) prim StrLength(s),
    substr = fun (s : String, i : Int) prim StrSubstr(s, i),
    lt = fun (l : String, r : String) prim StrLt(l, r),
    lte = fun (l : String, r : String) prim StrLte(l, r),
    gt = fun (l : String, r : String) prim StrGt(l, r),
    gte = fun (l : String, r : String) prim StrGte(l, r)
  }

  // Useful type constructors

  def Option (T : Type) Type = <<None : Unit, Some : T>>

  def Either (A : Type, B : Type) Type = <<Left : A, Right : B>>

  val Vectors = {

    // primitives
    val append = fun (t : Type, v : Vector(t), e : t) prim VecAppend(t, v, e)
    val concat = fun (t : Type, l : Vector(t), r : Vector(t)) prim VecConcat(t, l, r)
    val get = fun (t : Type, v : Vector(t), i : Int) prim VecGet(t, v, i)
    val length = fun (t : Type, v : Vector(t)) prim VecLength(t, v)
    val prepend = fun (t : Type, v : Vector(t), e : t) prim VecPrepend(t, v, e)
    val put = fun (t : Type, v : Vector(t), i : Int, e : t) prim VecPut(t, v, i, e)

    def contains(t : Type, v : Vector(t), x : t) Boolean = {
      def aux(i : Int) Boolean =
        i < length(t, v) match {
          case True(_) =>
            get(t, v, i) == x match {
              case True(_) => true
              case False(_) => aux(i + 1)
            }
          case False(_) =>
            false
        }
      aux(0)
    }

    def exists(t : Type, v : Vector(t), p: (t) Boolean) Boolean = {
      def aux(i : Int) Boolean =
        i < length(t, v) match {
          case True(_) =>
            p(get(t, v, i)) match {
              case True(_) => true
              case False(_) => aux(i + 1)
            }
          case False(_) =>
            false
        }
      aux(0)
    }

    def filter(t : Type, v : Vector(t), p : (t) Boolean) Vector(t) = {
      def aux(i : Int, out : Vector(t)) Vector(t) =
        i < length(t, v) match {
          case True(_) => {
            val x = get(t, v, i)
            val next =
              p(x) match {
                case True(_) => append(t, out, x)
                case False(_) => out
              }
            aux(i + 1, next)
          }
          case False(_) =>
            out
        }
      aux(0, [])
    }

    def find(t : Type, v : Vector(t), p : (t) Boolean) Option(t) = {
      def aux(i : Int) Option(t) =
        i < length(t, v) match {
          case True(_) => {
            val x = get(t, v, i)
            p(x) match {
              case True(_) => <<Some = x>>
              case False(_) => aux(i + 1)
            }
          }
          case False(_) =>
            <<None = {}>>
        }
      aux(0)
    }

    def flatMap(t0 : Type, t1 : Type, v : Vector(t0), f : (t0) Vector(t1)) Vector(t1) = {
      def aux(i : Int, out : Vector(t1)) Vector(t1) =
        i < length(t0, v) match {
          case True(_) =>
            aux(i + 1, concat(t1, out, f(get(t0, v, i))))
          case False(_) =>
            out
        }
      aux(0, [])
    }

    def forall(t : Type, v : Vector(t), p : (A) Boolean) Boolean = {
      def aux(i : Int) Boolean =
        i < length(t, v) match {
          case True(_) =>
            p(get(t, v, i)) match {
              case True(_) => aux(i + 1)
              case False(_) => false
            }
          case False(_) =>
            true
        }
      aux(0)
    }

    def map(t0 : Type, t1 : Type, v : Vector(t0), f : (t0) t1) Vector(t1) = {
      def aux(i : Int, out : Vector(t1)) Vector(t1) =
        i < length(t0, v) match {
          case True(_) =>
            aux(i + 1, append(t1, out, f(get(t0, v, i))))
          case False(_) =>
            out
        }
      aux(0, [])
    }

    def reduce(t0 : Type, t1 : Type, v : Vector(t0), z : t1, f : (t1, t0) t1) t1 = {
      def aux(i : Int, out : t1) t1 =
        i < length(t0, v) match {
          case True(_) =>
            aux(i + 1, f(out, get(t0, v, i)))
          case False(_) =>
            out
        }
      aux(0, z)
    }

    def reverse(t : Type, v : Vector(t)) Vector(t) = {
      def aux(i : Int, out : Vector(t)) Vector(t) =
        i < length(t, v) match {
          case True(_) =>
            aux(i + 1, append(t, out, get(t, v, length(t, v) - i - 1)))
          case False(_) =>
            out
        }
      aux(0, [])
    }

    def slice(t : Type, v : Vector(t), start : Int, end : Int) Vector(t) = {
      val j = if end < length(t, v) then end else length(t, v)
      def aux(i : Int, out : Vector(t)) Vector(t) =
        i < end match {
          case True(_) => aux(i + 1, append(t, get(t, v, i)))
          case False(_) => out
        }
      aux(if 0 < start then start else 0, [])
    }

    {
      append = append,
      concat = concat,
      get = get,
      length = length,
      prepend = prepend,
      put = put,
      contains = contains,
      exists = exists,
      filter = filter,
      find = find,
      flatMap = flatMap,
      forall = forall,
      map = map,
      reduce = reduce,
      reverse = reverse,
      slice = slice
    }

  }

  // Capability types

  type Database = fun (A : Type) A

  type FolderReader = {
    read : (suffix : String) <<Left : String, Right : String>>
  }

  type RunnerReturn = {
    exitValue : Int,
    output : String
  }

  type FolderRunner = {
    run : (suffix : String, args : Vector(String)) <<Left : String, Right : RunnerReturn>>
  }

  type FolderWriter = {
    write : (suffix : String, s : String) <<Left : String, Right : Unit>>
  }

  type HttpReturn = {
    code : Int,
    body : String
  }

  type HttpDelete = {
    delete : (suffix : String) <<Left : String, Right : HttpReturn>>
  }

  type HttpGet = {
    get : (suffix : String) <<Left : String, Right : HttpReturn>>
  }

  type HttpPost = {
    post : (suffix : String) <<Left : String, Right : HttpReturn>>
  }

  type HttpPut = {
    put : (suffix : String) <<Left : String, Right : HttpReturn>>
  }

  type Reader = {
    read : () <<Left : String, Right : String>>
  }

  type Runner = {
    run : (args : Vector(String)) RunnerReturn
  }

  type DbError = {
    code : Int,
    message : String
  }

  type Table = fun (A : Type) {
    all : () Vector(A),
    getById : (Int) <<Some : A, None : Unit>>,
    insert : (A) <<Left : DbError, Right : Int>>,
    update : (A) <<Left : DbError, Right : Int>>,
    delete : (Int) <<Left : DbError, Right : Int>>
  }

  type Writer = {
    write : (s : String) <<Left : String, Right : Unit>>
  }

  {}
}
